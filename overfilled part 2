// variables obtain the game screen and dropper
const gameScreen = document.getElementById("gameScreen");
const dropper = document.getElementById("dropper");

let interval; // used as an interval for different action involving looping functions
let fishArray = []; // stores all the fish elements
let both = 0; // To check if both of the inputs are being pressed
let playMode = true; // used for pausing the game

// detects the input and outputs the droppers movement
function moveLeft() {
  let positionOfDropper = parseInt(window.getComputedStyle(dropper).getPropertyValue("left"));
  if (positionOfDropper > 0) {
    dropper.style.left = positionOfDropper - 2 + "px";
  }
}

function moveRight() {
  let positionOfDropper = parseInt(window.getComputedStyle(dropper).getPropertyValue("left"));
  if (positionOfDropper < 380) {
    dropper.style.left = positionOfDropper + 2 + "px";
  }
}

// obtains the offset of any element
function getOffset(obj) {
  const objPos = obj.getBoundingClientRect();
  const gameScreenPos = gameScreen.getBoundingClientRect();
  return {
    left: objPos.left - gameScreenPos.left + window.scrollX,
    top: objPos.top - gameScreenPos.top + window.scrollY
  };
}

// Event listener detects the input from the player
document.addEventListener("keydown", event => {
  if (both == 0) {
    both++;
    if (event.key === "ArrowLeft" || event.key === "a") {
      interval = setInterval(moveLeft, 1);
    }
    if (event.key === "ArrowRight" || event.key === "d") {
      interval = setInterval(moveRight, 1);
    }
  }

  if (event.key === "e") {
    // when e is pressed, a random fish will spawn
    let fish = document.createElement("div");
    let fishDropPool = Math.floor(Math.random() * 1); // will rotate between a few fish types
    FishType(fishDropPool, fish);
    FishSpawnPosition(fish, 40); // Positions below the dropper
  }
});

// Event listener for keyup to stop movement of the dropper
document.addEventListener("keyup", event => {
  clearInterval(interval);
  both = 0;
});

// function sets the spawn position of the fish
function FishSpawnPosition(fish, depthFromDropper) {
  let offsetOfDropper = getOffset(dropper);
  fish.style.position = "absolute";
  fish.style.left = offsetOfDropper.left + "px";
  fish.style.top = (offsetOfDropper.top + depthFromDropper) + "px"; 
  gameScreen.append(fish);
}

// function sets the spawn position of the fish after they merge
function fishNewPosition(fish, fishNewPositionInSpace) {
  fish.style.position = "absolute";
  fish.style.left = fishNewPositionInSpace.left + "px";
  fish.style.top = fishNewPositionInSpace.top + "px"; 
  gameScreen.append(fish);
}

// Gravity function drops the fish when they aren't colliding
function fishGravity(fish) {
  fish.gravity = 0.1;
  fish.speedY = 0;
  
  function update() {
    fish.speedY += fish.gravity;
    let newPosition = parseFloat(fish.style.top) + fish.speedY;
    
    // if statement makes sure the fish cannot fall off the screen
    if (newPosition < 500 - fish.offsetHeight && !fishCollisionChecker(fish)) {
      fish.style.top = newPosition + "px";
      requestAnimationFrame(update);

    } else if (fishCollisionChecker(fish)) {
      fish.style.top = fish.style.top; // Stop if colliding
    } else {
      fish.style.top = (500 - fish.offsetHeight) + "px"; // Stop at the bottom
      fish.speedY = 0;
    }
  }
  requestAnimationFrame(update);
}

// fish collision checker is used as a detector for the collision
function fishCollisionChecker(fish) {
  for (let i = 0; i < fishArray.length; i++) {
    const otherFish = fishArray[i];
    if (otherFish === fish || !otherFish) continue; // Skip itself and undefined fish

    const colliderA = fish.getBoundingClientRect();
    const colliderB = otherFish.getBoundingClientRect();

    // Check if the two fish are colliding
    if (colliderA.x < colliderB.x + colliderB.width &&
        colliderA.x + colliderA.width > colliderB.x &&
        colliderA.y < colliderB.y + colliderB.height &&
        colliderA.y + colliderA.height > colliderB.y) {
      return true; 
    }
  }
  return false; 
}

// Function to perform an action when the collision occurs
function fishCollision() {
  let fishToRemove = [];  // Track fish to be removed after the loop

  for (let i = 0; i < fishArray.length; i++) {
    for (let j = i + 1; j < fishArray.length; j++) {
      const fishA = fishArray[i];
      const fishB = fishArray[j];

      if (!fishA || !fishB) continue;  // Skip undefined fish

      const colliderA = fishA.getBoundingClientRect();
      const colliderB = fishB.getBoundingClientRect();

      // checks if two parts are colliding
      if (colliderA.x < colliderB.x + colliderB.width &&
          colliderA.x + colliderA.width > colliderB.x &&
          colliderA.y < colliderB.y + colliderB.height &&
          colliderA.y + colliderA.height > colliderB.y) {

        if (JSON.stringify([...fishA.classList].sort()) === JSON.stringify([...fishB.classList].sort())) {
          // merges the fish and upgrades them if they are the same id
          let fishPosition = getOffset(fishA);
          let fishIdNumber = parseInt(fishA.id.replace(/\D/g, ""));
          
          // Mark the fish for removal
          fishToRemove.push(fishA, fishB);

          // Remove the merged fish and create a new one
          let fish = document.createElement("div");
          FishType(fishIdNumber + 1, fish);
          fishNewPosition(fish, fishPosition);

          // Apply gravity to the new fish
          fishGravity(fish);
        } else {
          // if they are colliding it will push the block upwards
          let fishBTop = parseInt(fishB.style.top) || 0;
          fishB.style.top = (fishBTop - 1) + "px";
        }
      }
    }
  }

  // Remove marked fish after the loop finishes
  fishToRemove.forEach(fish => {
    const index = fishArray.indexOf(fish);
    if (index !== -1) {
      fishArray.splice(index, 1); // Remove from array
      fish.remove(); // Remove from DOM
    }
  });
}

// function creates the fish based on its id
function FishType(IdOfFish, fish) {
  switch (IdOfFish) {
    case 0:
      fish.setAttribute("class", "fishZero");
      fish.setAttribute("id", "0");
      break;
    case 1:
      fish.setAttribute("class", "fishOne");
      fish.setAttribute("id", "1");
      break;
    case 2:
      fish.setAttribute("class", "fishTwo");
      fish.setAttribute("id", "2");
      break;
    default:
      fish.setAttribute("class", "fishZero");
      fish.setAttribute("id", "0");
      break;
  }

  fishGravity(fish); // applies the gravity to the fish
  fishArray.push(fish); // this will put the fish into the array
}

// game loop repeats important detection functions
function gameLoop() {
  fishCollision(); // Check for fish collisions
  window.requestAnimationFrame(gameLoop); // Repeat the game loop
}

// start the game loop
window.requestAnimationFrame(gameLoop);
